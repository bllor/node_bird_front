spa는 첫 로딩 시 프론트 서버에서 자바스크립트 등의 파일을 받은 다음,
다음 요청부터는 백엔드 서버에 요청을 한다.

리액트를 쓰는 곳은 고객들에게 빠르게 인터렉션이 필요할 때 사용된다.
ssr: 첫 방문만 서버들을 거쳐서 정보를 받아오지만, 그 다음부터는 브라우저에서 백엔드 서버로 데이터 요청을 한다.

넥스트는 pages 폴더 안에 있는 파일들은 전부다 코드 스플리팅을 해준다.

넥스트 서버가 실행된 다음에 페이지를 추가할 경우, 페이지가 추가가 안되는 경우가 있는데,
이럴 때는 서버를 껐다 켜면 된다.

next 에서는 리액트 라우터 말고 Link를 사용한다.

css를 배치할 때는 가로를 먼저 나누고, 세로를 나누면 된다

반응형 디자인을 할 때는 모바일,테블릿,데스트탑 순서로 작업해야 한다.

antd는 24개의 칼럼으로 되어 있고,
xs:모바일 sm:태블릿 md:작은데스크탑
<Col xs={24} md={6} />
모바일일 때는 100%를 차지하고, 화면이 커질 경우 해당 화면의 25%를 차지한다는 코드
합쳐서 24이하면 같은 줄에서 나오고,
24가 넘을 경우 다른 줄에 나온다.
gutter : 컬럼 사이의 간격

_blank로 창을 열 때 보안의 위협이 있으므로, noreferrer ,nopener를 추가해준다.
 target="_blank"
            rel="noreferrer nopener"

발생하는 오류는 블로그에 작성하는 것이 좋다.

컴포넌트에 props로 넘겨주는 함수는 useCallback을 사용해야 최적화가 된다.

<div style={{ marginTop: "18px" }}>
자바스크립트에서 객체는 비교할 때마다 false가 된다.
위의 태그처럼 style={{}}을 객체로 넣을 경우, 리액트가 리랜더링 될 때마다 false가 되어 해당 div내의 부분을 리랜더링하게 된다.

ant design의 Input.Search를 스타일 컴포넌트로 만들어서 css를 적용하고 싶으면,
const SearchInput = styled(Input.Search)`
위의 코드와 같이 ()안에 넣어주고 작업하면 된다.
스타일 컴포넌트로 바꾸고 싶지 않으면, useMemo를 사용한다.
const Newstyle = UseMemo(()=>({marginTop:18}),[]);
이렇게 하고, <div style={Newstyle}> 이렇게 넣으면 된다.

함수형 컴포넌트에서 리랜더링 될 때는 함수 내의 모든 것이 재실행 된다.
useCallback, useMemo 는 캐싱이라서 배열 부분이 변경되지 않으면 재실행 되지 않는다.
return부분 중에 바뀌는 부분이 있으면 해당 부분만 재실행 된다.


리액트에서 배열로 jsx를 사용하려면 key를 붙혀주어야 한다.

noreferrer : 이전페이지를 알려주지 않는 것
nopener : 어디서 열었는지 안알려주는 것 

리랜더링 되는 것이 성능이 나빠지는 것은 아닌데, 화면을 다시 그리고 함수가 다시 실행되면 성능에 이슈를 줄 수 있다.

제이쿼리를 사용할 때는 리액트와 분리하여 사용해야 한다.

코드가 100줄이 넘어가면 컴포넌트를 분리하기?

커스텀 훅: 반복문, 조건문, 함수 안에서는 사용 못하고, 컴포넌트 안에서만 사용 가능하다.


const onSubmit = useCallback(
  (e) => {
    e.preventDefault(); // 기본 동작 방지
    console.log("passwordCheck 값:", passwordCheck); // 디버깅용
    if (password !== passwordCheck) {
      console.log("비밀번호 불일치:", password, "|", passwordCheck);
      return setPasswordError(true);
    }
    if (!term) {
      return setTermError(true);
    }
    console.log("회원가입 성공:", { id, nickName, password });
  },
  [password]
)
해당 함수를 사용할 때 passwordCheck값이 pass와 같은데도 불구하고,
일치하지 않는다고 하고, console.log에 값이 출력되지 않는 문제가 있었다.
useCallback은 의존성 배열에 값이 없을 경우, 첫 로딩시의 값을 가지고 사용하는데,
passwordCheck는 의존성 배열에 없으므로, 첫로딩 시 값인 ''이 나왔던 것이다.
그래서 아래와 같이 수정을 하니 함수가 작동을 잘하는 것을 확인할 수 있었다.

const onSubmit = useCallback(
  (e) => {
    e.preventDefault(); // 기본 동작 방지
    console.log("passwordCheck 값:", passwordCheck); // 디버깅용
    if (password !== passwordCheck) {
      console.log("비밀번호 불일치:", password, "|", passwordCheck);
      return setPasswordError(true);
    }
    if (!term) {
      return setTermError(true);
    }
    console.log("회원가입 성공:", { id, nickName, password });
  },
  [password, passwordCheck, term]
)

리덕스는 코드를 입력해야하는 양이 많아서 생산성이 좋지 않다.
리덕스를 사용하는 이유는 여러 컴포넌트들에서 공통으로 사용되는 경우,
중앙데이터 저장소를 만들어서 사용하는데, 리덕스가 중앙데이터 역할을 한다.
리덕스는 원리가 간단하고, 추적하기 쉽다. 코드 입력량이 많다.
컨텍스트 api에서는 비동기 처리를 하기 힘들고 직접 구현해야 한다.

리덕스
리덕스에서는 데이터를 변경하려면 action을 만들어야함 (type은 action의 이름)
액션을 dispatch하면 중앙저장소인 redux의 데이터가 변경된다.
액션이 dispatch되면 reducer에서 액션에 따라 실행을 다르게 한다.
데이터를 변경할 때마다 action을 만들어주고, reducer에 어떻게 처리할지 적어줘야해서 코드량이 많다.

*자바스크립트의 불변성
{} ==={} //false
const a  = {}
b = a
a===b// true

리듀서에서 객체를 새로 만들어서 보내주는데 그 이유는?
기록을 남기기 위해서,
const prev = {name:'dd'}
const next = {name:'aa'}
이렇게 두 개는 서로 다르다.
const next = prev;
next.name ='aa';
이렇게 하면 prev가 'aa'가 되므로, 비교할 데이터가 없어진다.

return{...state, name:action.data}
...state를 하는 이유는 메모리를 아끼기 위해서.
변경되지 않을 때도 새로운 객체를 계속 생성하여 메모리 소비가 있다.

store는 저장소와 reducer를 포함한 것

redux dev tools에서 diff는 어떻게 변했는지 알 수 있게 해줌
버튼 클릭 시 상태변경도 가능하므로 편함


시퀄라이즈에서 정보가 겹칠 경우, 합쳐서 주는데 대문자로 내보내줌

{mainPosts.map((post,index) => (
        <PostCard></PostCard>
      ))}
다음과 같이 배열을 map으로 사용할 때 index를 키로 사용하는 것은 좋지 않다.
반복되는 것들이 지워지거나, 순서가 변경되거나 추가가 될 때는 사용하면 안좋다.
반복문이 안바뀔 때는 사용해도 됨


컴포넌트로 분리할 때는 덩어리를 분리하거나, map안에 있는 애들을 분리하는 것이 좋다.

renderItem={(item) => {
              <li>
                <Comment
                  author={item.User.nickName}
                  avatar={<Avatar>{item.User.nickName}</Avatar>}
                  content={item.content}
                ></Comment>
              </li>
            }}
다음과 같이 사용할 때 리턴 되지 않는 이슈가 있었다.
지피티에게 물어보니 
renderItem={(item) => (
              <li>
                <Comment
                  author={item.User.nickName}
                  avatar={<Avatar>{item.User.nickName}</Avatar>}
                  content={item.content}
                ></Comment>
              </li>
            )}            
다음과 같이 사용해야 한다고 했다.
()=>() 와 ()=>{}는 비슷하게 생긴 것 같은데 왜 동작하는 것이 다를까?
()=>()
특징: 중괄호({}) 대신 소괄호(())를 사용하면, 화살표 함수는 중괄호 없이 표현식(expression)을 평가하고 그 결과를 자동으로 반환합니다.
주로 사용: 함수가 단일 표현식만 반환하는 경우
()=>{}
특징: 중괄호({})를 사용하면 함수 본문을 명시적으로 정의하고, 반환값을 주려면 return 키워드를 써야 합니다.
주로 사용: 복잡한 로직이 있는 함수.

const Overlay = styled.div₩₩
위와 같은 형태로 스타일컴포넌트를 사용하는데, 이는 자바스크립트의 문법이다.
함수를 불러오는 방법 중에 ₩₩으로 불러오는 방법이 있기 때문.

이미 정해져있는 클래스명에 있는 css를 수정하려면 글로벌스타일로 적용해준다.

css에 transform이 있는 경우, position:fixed를 정확히 잡지 못한다.

